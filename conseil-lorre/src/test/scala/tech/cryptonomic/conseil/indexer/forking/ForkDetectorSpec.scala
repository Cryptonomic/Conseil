package tech.cryptonomic.conseil.indexer.forking

import tech.cryptonomic.conseil.indexer.ForkDetector
import org.scalatest.propspec.AnyPropSpec
import org.scalatest.matchers.should.Matchers
import org.scalatestplus.scalacheck.ScalaCheckDrivenPropertyChecks
import org.scalacheck.{Arbitrary, Gen}
import cats.implicits._

/** Here we verify the properties of the [[ForkDetector]] implementation.
  * We use the Property-based-testing approach, where pseudo-random values are
  * generated by the test-harness to proof that a given set of assumptions are
  * verified for all the generated values.
  * We care to generate arbitrary ranges of levels to test our detector, and
  * guarantee that it will find the forking point independently of the test values.
  */
class ForkDetectorSpec extends AnyPropSpec with ScalaCheckDrivenPropertyChecks with Matchers {

  import Fixtures._

  /* each property call will generate a hundred test values and verify the assertion on each of them,
   * unless a different acceptance threshold is defined, using
   *
   * forAll(minSuccessful(<runs>)) {...}
   *
   * Similarly we can establish how many discarded values (by a `whenever(predicate)` block) are
   * acceptable, as a multiplier of the overall successes.
   * E.g. forAll(maxDiscardedFactor(3.0)) means that for 100 successful runs, no more than 300
   * test values should've been discarded by using `whenever`.
   */

  property("The fork-detection algorithm should identify the forking point in arbitrary ranges") {
    forAll { (range: ForkDetectionRange) =>
      val sut = detector(forkingPoint = range.fork)

      sut.searchForkLevel(range.low, range.high) shouldBe range.fork
    }
  }

  property("The fork detection level check should return consistent results below the forking point") {
    forAll(maxDiscardedFactor(3.0)) { (range: ForkDetectionRange, level: Long) =>
      whenever(level < range.fork) {
        val sut = detector(forkingPoint = range.fork)
        sut.checkOnLevel(level) shouldBe ForkDetector.SameId
      }
    }
  }

  property("The fork detection level check should return consistent results above the forking point") {
    forAll(maxDiscardedFactor(3.0)) { (range: ForkDetectionRange, level: Long) =>
      whenever(level >= range.fork) {
        val sut = detector(forkingPoint = range.fork)
        sut.checkOnLevel(level) shouldBe ForkDetector.ForkedId
      }
    }
  }

  /** Defines all necessary data, generators, dummy objects to run the test */
  private object Fixtures {
    /* we only use two possible block id values, since we only need to
     * test if they match or not for a single level, but care not what are
     * the actual values.
     * The dummy services that return block-ids per level, will be defined
     * as to provide the same block id value for inputs below a specific level
     * and different ids for inputs above such level, where such level is when
     * the fork is supposed to be happened.
     * We can encode two values as an either type where we don't care about
     * the actual content, but we only differentiate if it's left or right.
     * Thus we can put a Unit value in the Either, which doesn't force any
     * choice of value as content.
     */
    type BlockId = Either[Unit, Unit]
    val blockA: BlockId = Left(())
    val blockB: BlockId = Right(())

    /* Our test detector will always return the same id for the indexer.
     * In the case of the node search, up-to the given [[forkingPoint]]
     * we'll receive the same indexer id, and the other one above the fork.
     *
     * The effect wrapping the results used for the test is [[cats.Id]],
     * which is nothing but an alias for an empty wrapper, which corresponds
     * directly to the underlying content type,
     *  e.g. a cats.Id[Int] = Int
     */
    def detector(forkingPoint: Long) = new ForkDetector[cats.Id, BlockId](
      indexerSearch = (_) => blockA,
      nodeSearch = lvl => if (lvl >= forkingPoint) blockB else blockA
    )

    /** we want to test by generating random triplets that
      * define the lower/upper bounds of a range of levels and
      * the internal forking level in-between.
      * This class captures our intent
      */
    case class ForkDetectionRange(low: Long, fork: Long, high: Long)

    /** this arbitrary instance will generate ranges of positive numbers
      * up to a cap (1e6 for this test) with a value in between, representing
      * the fork point
      * The property-check library will use this instance to generate multiple
      * values of ForkDetectionRange, with the rules hereto outlined, and
      * run the test assertions for each of those generated ranges.
      */
    implicit val rangeGenerator: Arbitrary[ForkDetectionRange] = Arbitrary(
      for {
        low <- Gen.choose(0L, 1000) //arbitrary positive number with a cap
        high <- Gen.choose(low + 2, low + 1000000) //arbitrary number in a range
        fork <- Gen.choose(low + 1, high - 1) //arbitrary number in-between
      } yield ForkDetectionRange(low, fork, high)
    )

  }
}
